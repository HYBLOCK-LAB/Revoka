
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Week 1: Smart Contract와 Solidity 익히기</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="html"
                  title="Week 1: Smart Contract와 Solidity 익히기"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="세션 소개" duration="5">
        <p>이번 세션은 Solidity를 사용하여 Smart Contract 개발에 대해 이해하는 것이 목적입니다. 여러분은 단순히 문법을 배우는 것을 넘어, 이더리움 생태계의 핵심 원리를 이해하고, 스마트 컨트랙트를 작성하여 블록체인 상에 배포하는 개발 과정을 경험하게 됩니다.</p>
<h2 is-upgraded>목차</h2>
<h3 is-upgraded>1. 이더리움(Ethereum)</h3>
<p>블록체인의 기본 원리를 바탕으로 이더리움이 어떻게 동작하는지 알아봅니다. 사용자가 상호작용하는 <strong>계정(EOA/CA)</strong>, 모든 상태 변화를 일으키는 트랜잭션, 그리고 연산의 대가로 지불하는 <strong>가스(Gas)</strong> 의 개념을 명확히 이해합니다.</p>
<h3 is-upgraded>2. EVM(Ethereum Virtual Machine)</h3>
<p>스마트 컨트랙트가 실행되는 격리된 샌드박스 환경인 EVM의 아키텍처를 살펴봅니다. EVM이 데이터를 처리하는 핵심 영역인 <strong>스택(Stack), 메모리(Memory), 스토리지(Storage)</strong> 의 차이점을 배우고, 이것이 가스비와 프로그래밍에 어떤 영향을 미치는지 알아봅니다.</p>
<h3 is-upgraded>3. 스마트 컨트랙트(Smart Contract)</h3>
<p>스마트 컨트랙트의 라이프사이클, 즉 작성 → 컴파일 → 배포 → 실행에 이르는 전체 단계를 명확히 이해하고 컨트랙트의 기본 구조를 파악합니다. 또한, 결정론적 프로그램에 대해 알아 봅니다.</p>
<h3 is-upgraded>4. Solidity</h3>
<p>스마트 컨트랙트 작성을 위한 필수 문법을 예제 코드와 함께 학습합니다. 블록체인에 영구히 기록될 상태 변수, 컨트랙트의 기능을 정의하는 함수와 제어문, 그리고 데이터를 효율적으로 관리하는 <strong>매핑(Mapping)</strong> 과 <strong>구조체(Struct)</strong> 사용법을 익힙니다.</p>
<h3 is-upgraded>5. 환경 설정 및 테스트</h3>
<p>개발을 위해 Ethereum IDE인 <strong>리믹스(Remix IDE)</strong> 와 <strong>HardHat</strong>을 중심으로 개발 환경을 설정합니다. 가상의 테스트넷에 컨트랙트를 배포하고, 작성한 함수의 기능이 올바르게 동작하는지 테스트하고 디버깅하는 방법을 실습합니다.</p>
<h3 is-upgraded>6. 프로젝트 준비</h3>
<p>진행할 프로젝트의 요구사항을 정의하고 아키텍처를 소개합니다. 앞으로 구현해야할 기능과 주의해야할 점을 함께 살펴 봅니다.</p>


      </google-codelab-step>
    
      <google-codelab-step label="이더리움(Ethereum)" duration="15">
        

      </google-codelab-step>
    
      <google-codelab-step label="EVM(Ethereum Virtual Machine)" duration="0">
        <p class="image-container"><img alt="EVM" src="img/e63221f86b9b235.png"></p>
<h3 is-upgraded>Storage</h3>
<p>블록체인에 영구적으로 저장되는 데이터입니다. 스토리지는 키(Key)와 값(Value) 쌍으로 이루어진 구조를 가집니다. 각 키와 값의 크기는 32byte입니다. 주로 함수 외부에 정의 된 변수, 함수와 같은 스마트 컨트랙트의 주요 정보가 저장되며 영속적입니다 따라서 가스비가 가장 비쌉니다.</p>
<h3 is-upgraded>Memory</h3>
<p>함수나 반복문이 실행되는 동안에만 임시로 데이터를 저장합니다. 함수 실행이 끝나면 사라지며, Storage보다 훨씬 저렴합니다. 함수의 경우 함수가 실행될 때 매개변수, 반환값, 함수 내부의 변수와 같은 데이터가 Memory에 저장됩니다. 즉, 함수가 실행될 대마다 메모리는 <strong>깨끗한</strong> 상태에서 데이터를 저장한 후 함수 실행이 끝나면 데이터가 삭제됩니다.</p>
<h3 is-upgraded>Calldata</h3>
<p>외부에 있는 함수(EOA(Externally Owned Accounts) 또는 다른 컨트랙트)가 함수를 호출할 때 전달하는, 수정 불가능한 임시 데이터 영역입니다. Memory와 비슷하지만 **수정이 불가능(읽기 전용)**하며, 가스비가 가장 저렴합니다. 주로 가시성 지정자 <code>external</code>이 적용된 함수의 매개변수가 사용합니다.</p>
<h3 is-upgraded>Stack</h3>
<p>Stack은 EVM에서 휘발성을 가진 데이터를 유지 관리하는 공간입니다. 보통 Solidity 개발할 때 직접적으로 접근하지 않습니다. Stack의 최대 깊이는 1024입니다.</p>


      </google-codelab-step>
    
      <google-codelab-step label="스마트 컨트랙트(Smart Contract)" duration="15">
        

      </google-codelab-step>
    
      <google-codelab-step label="Solidity" duration="30">
        <h2 is-upgraded>구조 (라이센스, 버전 표기 등)</h2>
<p>Solidity 파일의 기본 구조는 다음과 같습니다. 이 구조는 모든 Solidity 계약에서 기본적으로 포함되어야 합니다.</p>
<pre><code language="language-solidity" class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract Hello {
    // 스마트 계약 내용
}
</code></pre>
<ol type="1">
<li>SPDX-License-Identifier: MITSPDX 라이선스는 솔리디티 컴파일러 버전 0.6.8부터 스마트 컨트랙트 최상단에 명시해야 합니다. 스마트 컨트랙트 소스 코드는 공유되어 사용할수록 코드의 신뢰도가 높아집니다. <code>MIT</code> 라이선스는 자유롭게 사용하고 수정할 수 있는 조건을 제공하는 오픈소스 라이선스입니다. 다른 라이선스를 사용하려면 적절한 SPDX 식별자를 선택해야 합니다.</li>
<li>pragma solidity ^0.8.24;pragma solidity는 현재 작성된 스마트 컨트랙트의 솔리디티 컴파일러 버전을 나타냅니다. 이 코드는 스마트 계약의 호환성 범위를 지정합니다. ^0.8.24는 컴파일러가 0.8.24 버전 이상이지만 0.9.0 미만일 경우에만 컴파일이 가능하다는 의미입니다. 이 구문은 코드의 정확한 버전 호환성을 보장하여, 버전 차이로 인한 에러를 방지하는 데 도움을 줍니다.</li>
<li>contractscontract는 스마트 계약의 시작을 알리는 키워드입니다. 이 구문은 contract {컨트랙트 이름}의 형태로 작성되며, Solidity에서 스마트 계약을 정의할 때 사용됩니다. Hello는 이 계약의 이름이며, 계약 내에서 정의된 함수나 상태 변수들을 포함할 수 있습니다.</li>
<li>주석 주석은 코드의 부연 설명이나 메모 정도로 생각하면 됩니다. 개발자를 위한 용도로 사용되면 프로그램의 동작에는 영향을 미치지 않습니다. 이번 세션에서는 코드의 부연 설명을 위해 주로 사용할 예정입니다.주석의 종류는 두 가지가 있습니다:<ul>
<li>행 단위 주석 (//): 한 줄만 주석 처리할 때 사용합니다.</li>
</ul>
<pre><code language="language-solidity" class="language-solidity">// 이 변수는 숫자를 저장합니다
uint public number;

</code></pre>
<ul>
<li>블럭 단위 주석 (/_ ... _/): 여러 줄의 주석을 한 번에 작성할 때 사용합니다.</li>
</ul>
<pre><code language="language-solidity" class="language-solidity">// 이 변수는 숫자를 저장합니다
uint public number;

</code></pre>
</li>
</ol>
<h2 is-upgraded>변수와 자료형</h2>
<h3 is-upgraded>변수</h3>
<p>변수는 변하는 값을 가질 수 있는 메모리 공간입니다. 밑의 예시는 변수를 정의하는 방법입니다. 변수를 처음 정의할 때 <strong>자료형</strong>을 변수에 명시해야 하며 변수명은 <strong>예약어</strong>만 제외하고 자유롭게 정할 수 있습니다. 예시에서 변수명은 a이고 값은 5입니다. 변수명을 정할 때는 무슨 용도인지 알아보기 쉽도록 작성하는 것을 추천드립니다. 변수명은 주로 소문자로 시작하고 숫자와 특수기호로 시작하는 이름은 지을 수 없습니다.</p>
<pre><code language="language-solidity" class="language-solidity">  uint a = 5;
</code></pre>
<h3 is-upgraded>자료형</h3>
<p>자료형은 데이터를 분류하는 기준이고 크게 값 타입(Value Type)과 참조 타입(Reference Type)이 있습니다. 먼저 값 타입에 대해 알아봅시다. 변수가 전달될 때 값(value)이 전달됩니다. 즉, 이 타입이 함수의 인자로 사용되거나 할당값으로 사용될 땐, 값이 복사됩니다.</p>
<h3 is-upgraded>값 타입 자료형</h3>
<aside class="warning"><p><strong>Tip:</strong> Value Type에는 struct도 포함됩니다.Primitive type과는 차이가 있습니다.</p>
</aside>
<ol type="1">
<li>Booleans bool: 가능한 값은 상수 true 그리고 false 입니다.연산자:<ul>
<li><code>!</code> (논리 부정)</li>
<li><code>&&</code> (논리 AND, &#34;and&#34;)</li>
<li><code>||</code> (논리 OR, &#34;or&#34;)</li>
<li><code>==</code> (같음)</li>
<li><code>!=</code> (같지 않음)</li>
</ul>
<code>||</code> 과 <code>&&</code> 에는 일반적인 short-circuiting rules이 적용됩니다. 이것은 <code>f(x) || g(y)</code> 에서 만약 <code>f(x)</code> 가 true 라면, <code>g(y)</code> 의 값을 확인하지 않는다면 부작용이 있을 수 있음에도 불구하고 값을 확인하지 않는것을 의미합니다.</li>
<li>정수 int / uint: 다양한 크기의 부호있는 정수 타입, 부호없는 정수 타입이 존재합니다. uint8 에서 uint256 까지, 그리고 int8 부터 int256 까지 8비트 단위로 키워드가 존재합니다. uint 와 int 는 각각 uint256 와 int256 의 별칭입니다. 사용 가능한 정수 타입과 범위는 다음과 같습니다.<br> <br><strong>int 범위</strong><table>
<tr><td colspan="1" rowspan="1"><p><strong>타입</strong></p>
</td><td colspan="1" rowspan="1"><p>** 범위 **</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>int8</p>
</td><td colspan="1" rowspan="1"><p>[-128, 127] (= [-27, -27 - 1])</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>int16</p>
</td><td colspan="1" rowspan="1"><p>[-32,768, 32,767] (= [-215, -215 - 1])</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>int32</p>
</td><td colspan="1" rowspan="1"><p>[-2,147,483,648, 2,147,483,647] (= [-231, -231 - 1])</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>int64</p>
</td><td colspan="1" rowspan="1"><p>[-263, -263 - 1]</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>int128</p>
</td><td colspan="1" rowspan="1"><p>[-2127, -2127 - 1]</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>int256</p>
</td><td colspan="1" rowspan="1"><p>[-2255, -2255 - 1]</p>
</td></tr>
</table>
<br> <br><strong>uint 범위</strong><table>
<tr><td colspan="1" rowspan="1"><p><strong>타입</strong></p>
</td><td colspan="1" rowspan="1"><p>** 범위 **</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>uint8</p>
</td><td colspan="1" rowspan="1"><p>[0, 255] (= [0, -28 - 1])</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>uint16</p>
</td><td colspan="1" rowspan="1"><p>[0, 65,535] (= [0, -216 - 1])</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>uint32</p>
</td><td colspan="1" rowspan="1"><p>[0, 4,294,967,295] (= [0, -232 - 1])</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>uint64</p>
</td><td colspan="1" rowspan="1"><p>[0, -264 - 1]</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>uint128</p>
</td><td colspan="1" rowspan="1"><p>[0, -2128 - 1]</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>uint256</p>
</td><td colspan="1" rowspan="1"><p>[0, -2256 - 1]</p>
</td></tr>
<tr><td colspan="2" rowspan="1"></td><td colspan="1" rowspan="1"></td></tr>
</table>
연산자:<ul>
<li>비교 연산자: &lt;=, &lt;, ==, !=, &gt;=, &gt; (bool 결과값을 가짐)</li>
<li>비트 연산자: &amp;, |, ^ (배타적 비트 or), ~ (비트 보수)</li>
<li>산술 연산자: +, -, 단항 -, 단항 +, *, /, % (나머지), ** (거듭제곱), « (왼쪽 시프트), » (오른쪽 시프트)</li>
</ul>
나눗셈의 결과는 항상 정수이며 소수부분은 절사됩니다(EVM의 DIV opcode로 컴파일 됩니다). 그러나 두 연산자가 literals (또는 리터럴 표현식)인 경우 소수부분은 절사되지 않습니다.0으로 나누거나 0으로 모듈로 연산을 하면 런타임 예외가 발생합니다.시프트 연산 결과의 타입은 왼쪽 피연산자의 타입을 따릅니다. <code>x << y</code> 는 <code>x * 2**y</code> 와 동일하며, <code>x >> y</code> 는 <code>x / 2**y</code> 와 동일합니다. 이는 음수를 시프트하는 경우 부호가 확장됨을 의미합니다.(This means that shifting negative numbers sign extends.) 음수만큼 시프트 연산을 실행하는 경우 런타임 예외가 발생합니다.<aside class="warning"><p><strong>Warning</strong> 부호있는 음의 정수를 우측 시프트 연산 한 결과값은 다른 프로그래밍 언어에서의 결과값과 다릅니다. solidity에서는, 우측 시프트는 나눗셈과 매핑되며 그로 인해 시프트된 음의 값은 0으로 반올림되어 갑니다(절사). 다른 프로그래밍 언어에서는, 음의 값을 우측 시프트연산 하는 경우, 나눗셈과 소수점 이하 버림이 동시에 작동하는것과 유사하게 동작합니다(음의 무한대 방향).</p>
</aside>
</li>
<li>Bytes바이트 타입은 고정 바이트 배열과 동적 크기 바이트 배열로 나눌 수 있습니다. 고정 바이트 배열은 값 타입이고, 사용할 바이트의 길이(크기)를 미리 지정해야 합니다. 반면, 동적 바이트 타입은 참조 타입이며 사용할 바이트 값을 지정하지 않아도 됩니다.고정 바이트 타입은 bytes1부터 bytes32까지 있으며 각 숫자는 길이를 나타냅니다. 예를 들어 bytes4는 4바이트만 사용하겠다는 의미입니다.<pre><code language="language-solidity" class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract FixedByteArray {
    bytes4 public data;

    function setData(bytes4 _data) public {
        data = _data;  // 4바이트 고정 크기의 배열에 데이터를 저장
    }

    function getData() public view returns (bytes4) {
        return data;  // 저장된 4바이트 데이터를 반환
    }
}
</code></pre>
</li>
<li>Address 다른 프로그래밍 언어와 다르게 솔리디티는 주소형 타입이 존재합니다. 주소형 타입은 계정의 주소(e.g. 사용자 주소, 스마트 컨트랙트 주소)를 나타냅니다. 주소형 타입의 크기는 20byte로 고정되어 있습니다. 주로 16진수로 표현됩니다. 즉, 0x를 포함한 40자리 리터럴로 표현됩니다. (e.g. <code>0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</code>) 체크섬 테스트를 통과하지 못한 39자리 ~ 41자리 길이의 16진수 리터럴은 경고를 발생시키고 일반적인 유리수 리터럴로 취급됩니다.    <aside class="special"><p><strong>Tip: </strong> 혼합 케이스 address의 체크섬 형식은    <a href="https://github.com/ethereum/ercs/blob/master/ERCS/erc-55.md" target="_blank">EIP-55</a>에 정의되어 있습니다.</p>
</aside>
    <aside class="special"><p><strong>Tip: 유리수 및 정수 표기법</strong></p>
<p>일반적으로 정수는 10진수로 나타내어집니다. 솔리디티에서 8진법은 지원하지 않습니다. 16진수의 경우 숫자 앞에 <code>0x</code>를 붙여 나타냅니다</p>
<p>    소수점 이하 리터럴은 한쪽에 적어도 하나의 숫자가 있을때 . 에 의해 구성됩니다. 예로는 1., .1, 1.3 이 있습니다.    소수가 밑이 될 수 있지만 지수는 될 수 없는 과학적 표기법 또한 지원됩니다. 2e10, -2e10, 2e-10, 2.5e1 같은 예가 있습니다. </p>
<p>숫자는 리터럴이 아닌 타입으로 변환될때까지 임의 정밀도를 유지합니다. 이는 계산이 수행될때 <strong>오버플로우</strong>가 발생하지 않으며 나눗셈이 수행될때 자릿수를 잘라내지 않는걸 의미합니다.</p>
<p>예를 들어, (2**800 + 1) - 2**800 의 결과는 비록 중간 결과값이 machine word size에 적합하지 않을지라도 상수 1 (uint8 타입)입니다. 게다가 .5 * 8 의 결과값은 (비록 중간에 정수가 아닌 숫자가 사용되었을지라도) 정수 4 입니다.</p>
</aside>
</li>
</ol>
<h3 is-upgraded>참조 타입 자료형</h3>
<p>참조 타입은 데이터를 다른 위치에 저장하고 그 위치를 값으로 가집니다. 보통 메모리나 스토리지에 저장할 수 있습니다. 위치에 따라 가스비가 크게 달라질 수 있으므로 주의하여 사용하여야 합니다.</p>
<p>모든 복합 타입은 자신이 메모리나 스토리지 중 어디에 저장되었는지를 나타내는 &#34;데이터 위치&#34;가 추가적으로 존재합니다. 컨텍스트에 따라 항상 기본값이 존재하지만, 타입에 스토리지 나 메모리 를 추가하여 재정의 할 수 있습니다. 함수 매개 변수(반환 매개 변수도 포함)의 기본값은 메모리 이고, 지역 변수의 기본값은 스토리지 이며 상태 변수의 위치는 스토리지 로 강제되어 있습니다.</p>
<p>또한 세 번째 데이터 위치인 calldata 가 있으며, 여기에는 함수 인자가 저장되고 수정 불가능하며 지속성이 없습니다. 외부 함수의 함수 매개 변수(반환 매개변수 제외)는 calldata 에 강제 저장되며 거의 memory 처럼 작동합니다.</p>
<p>데이터 위치는 변수가 할당되는 방식을 변경하기 때문에 중요합니다: assignments between storage and memory and also to a state variable (even from other state variables) always create an independent copy. Assignments to local storage variables only assign a reference though, and this reference always points to the state variable even if the latter is changed in the meantime. 반면, 메모리에 저장된 참조 타입에서 다른 메모리에 저장된 참조 타입을 할당할땐 복사본을 만들지 않습니다.</p>
<h2 is-upgraded>함수 기본: 가시성/상태성/리턴</h2>
<h2 is-upgraded>자료형: 배열 / 매핑 / 구조체</h2>


      </google-codelab-step>
    
      <google-codelab-step label="환경 설정 및 테스트" duration="30">
        

      </google-codelab-step>
    
      <google-codelab-step label="프로젝트 준비" duration="14">
        

      </google-codelab-step>
    
      <google-codelab-step label="축하합니다" duration="1">
        <p>축하합니다! 성공적으로 이더리움과 스마트 컨트랙트의 개념에 대해 학습하였습니다.</p>
<h2 is-upgraded>도움이 될 만한 자료</h2>
<ol type="1">
<li><a href="https://cryptozombies.io" target="_blank">크립토 좀비</a>: 좀비 게임을 만들면서 Blockchain 기반 Dapp 기반을 학습할 수 있습니다. Solidity Course부터 진행하는 것을 추천드립니다.</li>
<li><a href="https://cloud.google.com/application/web3" target="_blank">Google Cloud Web3</a>: 구글 클라우드에서 만든 Web3 개발자 도구입니다. Ethureum(Sepolia)을 비롯한 다양한 코인의 Faucet을 지원합니다.</li>
<li><a href="https://remix.ethereum.org" target="_blank">Remix IDE</a>: 온라인 Remix IDE입니다.</li>
<li><a href="https://hardhat.org" target="_blank">Hardhat</a>: Hardhat 공식 웹 페이지입니다.</li>
</ol>
<h2 is-upgraded>참고 자료</h2>
<ol type="1">
<li><a href="https://ethereum.org/ko/developers/docs" target="_blank">Ethereum development documentation</a></li>
<li><a href="https://ethereum.github.io/yellowpaper/paper.pdf" target="_blank">Ethereum Yellow Paper</a></li>
<li><a href="https://solidity-kr.readthedocs.io/ko/latest/index.html" target="_blank">Solidity 공식 문서 한글 번역</a></li>
<li><a href="https://archive.devcon.org/devcon-1/ethereum-for-dummies/?tab=YouTube" target="_blank">Ethereum for Dummies</a>: 2015년 Ethereum Dev Con에서 진행했던 Dr. Gavin Wood(Ethereum&#39;s CTO)의 이더리움 소개 발표</li>
</ol>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
